<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="yzhe819"><title>MIT 6.S081 Lab 1 Xv6 和 Unix 实用程序 ｜ yzhe819</title><meta name=description content=" 本篇文章是第一个lab的记录
完成了基础的实验室内容
挑战练习有时间会再看看
官网链接：Lab: Xv6 and Unix utilities
代码仓库：Github
"><meta name=keywords content="yzhe819,zozo"><link rel="shortcut icon" href=https://yzhe819.github.io/images/favicon.ico><link rel=stylesheet type=text/css media=screen href=https://yzhe819.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css><link rel=stylesheet type=text/css media=screen href=https://yzhe819.github.io/css/zozo.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css><link rel=stylesheet type=text/css media=screen href=https://yzhe819.github.io/css/highlight.css></head><body><div class="main animate__animated animate__fadeInDown"><div class="nav_container animated fadeInDown"><div class=site_nav id=site_nav><ul><li><a href=/>Home</a></li><li><a href=/posts/>Archive</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul></div><div class=menu_icon><a id=menu_icon><i class=ri-menu-line></i></a></div></div><div class="header animated fadeInDown"><div class=site_title_container><div class=site_title><h1><a href=https://yzhe819.github.io/><span>yzhe819</span></a></h1></div><div class=description><p class=sub_title>yzhe819's Blog</p><div class=my_socials><a href=https://github.com/yzhe819 title=github target=_blank><i class=ri-github-fill></i></a>
<a href=https://yzhe819.github.io/index.xml type=application/rss+xml title=rss target=_blank><i class=ri-rss-fill></i></a></div></div></div></div><div class=content><div class=post_page><div class="post animate__animated animate__fadeInDown"><div class="post_title post_detail_title"><h2><a href=/posts/mit-6.s081-lab-1/>MIT 6.S081 Lab 1 Xv6 和 Unix 实用程序</a></h2><span class=date>2022.06.08</span></div><div class="post_content markdown"><blockquote><p>本篇文章是第一个lab的记录</p></blockquote><p>完成了基础的实验室内容</p><p>挑战练习有时间会再看看</p><p>官网链接：<a href=https://pdos.csail.mit.edu/6.S081/2020/labs/util.html>Lab: Xv6 and Unix utilities</a></p><p>代码仓库：<a href=https://github.com/yzhe819/MIT-6.S081/tree/util>Github</a></p><h2 id=启动xv6难度easy>启动xv6(难度：Easy)</h2><p>之前已经搭建好环境并且下载好xv6了。</p><p>进入到对应的路径并且切换到util分支上：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ <span class=nb>cd</span> xv6-labs-2020
</span></span><span class=line><span class=cl>$ git checkout util
</span></span><span class=line><span class=cl>Branch <span class=s1>&#39;util&#39;</span> <span class=nb>set</span> up to track remote branch <span class=s1>&#39;util&#39;</span> from <span class=s1>&#39;origin&#39;</span>.
</span></span><span class=line><span class=cl>Switched to a new branch <span class=s1>&#39;util&#39;</span>
</span></span></code></pre></div><p>xv6-labs-2020 存储库与本书的 xv6-riscv 略有不同；它主要添加一些文件。如果好奇，请查看 git 日志：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>$git</span> log
</span></span></code></pre></div><p>将使用<a href=http://www.git-scm.com/>Git</a>版本控制系统分发此和后续实验室作业所需的文件。上面切换到了一个分支 ( git checkout util)，其中包含为该实验室量身定制的 xv6 版本。要了解有关 Git 的更多信息，请查看 <a href=http://www.kernel.org/pub/software/scm/git/docs/user-manual.html>Git 用户手册</a>，或者，您可能会发现这个 <a href=http://eagain.net/articles/git-for-computer-scientists/>面向 CS 的 Git 概述</a>很有用。Git 允许您跟踪您对代码所做的更改。例如，如果您完成了一项练习，并且想要检查您的进度，您可以通过运行以下命令来<em>提交</em>您的更改：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git commit -am <span class=s1>&#39;my solution for util lab exercise 1&#39;</span>
</span></span><span class=line><span class=cl>Created commit 60d2135: my solution <span class=k>for</span> util lab exercise <span class=m>1</span>
</span></span><span class=line><span class=cl> <span class=m>1</span> files changed, <span class=m>1</span> insertions<span class=o>(</span>+<span class=o>)</span>, <span class=m>0</span> deletions<span class=o>(</span>-<span class=o>)</span>
</span></span></code></pre></div><p>git diff 您可以使用该命令 跟踪您的更改。运行git diff将显示自上次提交以来对您的代码git diff origin/util所做的更改，并将显示与初始 xv6-labs-2020 代码相关的更改。在这里，<code>origin/xv6-labs-2020</code>是 git 分支的名称，其中包含您为该类下载的初始代码。</p><p>构建并运行 xv6：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ make qemu
</span></span><span class=line><span class=cl>riscv64-unknown-elf-gcc    -c -o kernel/entry.o kernel/entry.S
</span></span><span class=line><span class=cl>riscv64-unknown-elf-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_UTIL -MD -mcmodel<span class=o>=</span>medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie   -c -o kernel/start.o kernel/start.c
</span></span><span class=line><span class=cl>...  
</span></span><span class=line><span class=cl>riscv64-unknown-elf-ld -z max-page-size<span class=o>=</span><span class=m>4096</span> -N -e main -Ttext <span class=m>0</span> -o user/_zombie user/zombie.o user/ulib.o user/usys.o user/printf.o user/umalloc.o
</span></span><span class=line><span class=cl>riscv64-unknown-elf-objdump -S user/_zombie &gt; user/zombie.asm
</span></span><span class=line><span class=cl>riscv64-unknown-elf-objdump -t user/_zombie <span class=p>|</span> sed <span class=s1>&#39;1,/SYMBOL TABLE/d; s/ .* / /; /^$/d&#39;</span> &gt; user/zombie.sym
</span></span><span class=line><span class=cl>mkfs/mkfs fs.img README  user/xargstest.sh user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie 
</span></span><span class=line><span class=cl>nmeta <span class=m>46</span> <span class=o>(</span>boot, super, log blocks <span class=m>30</span> inode blocks 13, bitmap blocks 1<span class=o>)</span> blocks <span class=m>954</span> total <span class=m>1000</span>
</span></span><span class=line><span class=cl>balloc: first <span class=m>591</span> blocks have been allocated
</span></span><span class=line><span class=cl>balloc: write bitmap block at sector <span class=m>45</span>
</span></span><span class=line><span class=cl>qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp <span class=m>3</span> -nographic -drive <span class=nv>file</span><span class=o>=</span>fs.img,if<span class=o>=</span>none,format<span class=o>=</span>raw,id<span class=o>=</span>x0 -device virtio-blk-device,drive<span class=o>=</span>x0,bus<span class=o>=</span>virtio-mmio-bus.0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>xv6 kernel is booting
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>hart <span class=m>2</span> starting
</span></span><span class=line><span class=cl>hart <span class=m>1</span> starting
</span></span><span class=line><span class=cl>init: starting sh
</span></span><span class=line><span class=cl>$ 
</span></span></code></pre></div><p>如果您在提示符下键入<code>ls</code>，您应该会看到类似于以下内容的输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ls
</span></span><span class=line><span class=cl>.              <span class=m>1</span> <span class=m>1</span> <span class=m>1024</span>
</span></span><span class=line><span class=cl>..             <span class=m>1</span> <span class=m>1</span> <span class=m>1024</span>
</span></span><span class=line><span class=cl>README         <span class=m>2</span> <span class=m>2</span> <span class=m>2059</span>
</span></span><span class=line><span class=cl>xargstest.sh   <span class=m>2</span> <span class=m>3</span> <span class=m>93</span>
</span></span><span class=line><span class=cl>cat            <span class=m>2</span> <span class=m>4</span> <span class=m>24256</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span>           <span class=m>2</span> <span class=m>5</span> <span class=m>23080</span>
</span></span><span class=line><span class=cl>forktest       <span class=m>2</span> <span class=m>6</span> <span class=m>13272</span>
</span></span><span class=line><span class=cl>grep           <span class=m>2</span> <span class=m>7</span> <span class=m>27560</span>
</span></span><span class=line><span class=cl>init           <span class=m>2</span> <span class=m>8</span> <span class=m>23816</span>
</span></span><span class=line><span class=cl><span class=nb>kill</span>           <span class=m>2</span> <span class=m>9</span> <span class=m>23024</span>
</span></span><span class=line><span class=cl>ln             <span class=m>2</span> <span class=m>10</span> <span class=m>22880</span>
</span></span><span class=line><span class=cl>ls             <span class=m>2</span> <span class=m>11</span> <span class=m>26448</span>
</span></span><span class=line><span class=cl>mkdir          <span class=m>2</span> <span class=m>12</span> <span class=m>23176</span>
</span></span><span class=line><span class=cl>rm             <span class=m>2</span> <span class=m>13</span> <span class=m>23160</span>
</span></span><span class=line><span class=cl>sh             <span class=m>2</span> <span class=m>14</span> <span class=m>41976</span>
</span></span><span class=line><span class=cl>stressfs       <span class=m>2</span> <span class=m>15</span> <span class=m>24016</span>
</span></span><span class=line><span class=cl>usertests      <span class=m>2</span> <span class=m>16</span> <span class=m>148456</span>
</span></span><span class=line><span class=cl>grind          <span class=m>2</span> <span class=m>17</span> <span class=m>38144</span>
</span></span><span class=line><span class=cl>wc             <span class=m>2</span> <span class=m>18</span> <span class=m>25344</span>
</span></span><span class=line><span class=cl>zombie         <span class=m>2</span> <span class=m>19</span> <span class=m>22408</span>
</span></span><span class=line><span class=cl>console        <span class=m>3</span> <span class=m>20</span> <span class=m>0</span>
</span></span></code></pre></div><p>这些是<code>mkfs</code>包含在初始文件系统中的文件；大多数是您可以运行的程序。您只运行了其中一个：<code>ls</code>。</p><p>xv6 没有<code>ps</code>命令，但是，如果您键入<code>Ctrl-p</code>，内核将打印有关每个进程的信息。如果您现在尝试，您将看到两行：一行用于<code>init</code>，另一行用于<code>sh</code>。</p><p>要退出 qemu，请输入：<code>Ctrl-a x</code>.</p><h2 id=sleep难度easy>sleep(难度：Easy)</h2><p>为 xv6实现 UNIX 程序<code>sleep</code>；您的<code>sleep</code>应该暂停用户指定的滴答数。单个滴答(tick)是 xv6 内核定义的时间概念，即来自计时器芯片的两次中断之间的时间。您的解决方案应该在文件 <code>user/sleep.c</code>中。</p><h3 id=提示>提示：</h3><ul><li>在开始编码之前，请阅读<a href=https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf>《book-riscv-rev1》</a>的第 1 章。</li><li>查看 user/ 中的其他一些程序（例如<code>user/echo.c</code>、<code>user/grep.c</code>和<code>user/rm.c</code>），了解如何获取传递给程序的命令行参数。</li><li>如果用户忘记传递参数，sleep 应该打印一条错误消息。</li><li>命令行参数作为字符串传递；您可以使用<code>atoi</code>将其转换为整数（请参阅 user/ulib.c）。</li><li>使用系统调用<code>sleep</code>。</li><li>请参阅<strong>kernel/sysproc.c</strong>以获取实现<code>sleep</code>系统调用的xv6内核代码（查找<code>sys_sleep</code>），<strong>user/user.h</strong>提供了<code>sleep</code>的声明以便其他程序调用，用汇编程序编写的<strong>user/usys.S</strong>可以帮助<code>sleep</code>从用户区跳转到内核区。</li><li>确保<code>main</code>调用<code>exit()</code>以退出程序。</li><li>将你的<code>sleep</code>程序添加到<strong>Makefile</strong>中的<code>UPROGS</code>中；完成后，<code>make qemu</code>将编译您的程序，您将能够从 xv6 shell 运行它。</li><li>查看 Kernighan 和 Ritchie 的书 《The C programming language (second edition) (K&R)》 以了解 C。</li></ul><p>从xv6 shell运行程序：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ make qemu
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>init: starting sh
</span></span><span class=line><span class=cl>$ sleep <span class=m>10</span>
</span></span><span class=line><span class=cl><span class=o>(</span>nothing happens <span class=k>for</span> a little <span class=k>while</span><span class=o>)</span>
</span></span><span class=line><span class=cl>$
</span></span></code></pre></div><p>如果程序在如上所示运行时暂停，则解决方案是正确的。运行<code>make grade</code>看看你是否真的通过了睡眠测试。</p><p>请注意，<code>make grade</code>运行所有测试，包括下面作业的测试。如果要对一项作业运行成绩测试，请键入（不要启动XV6，在外部终端下使用）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ./grade-lab-util sleep
</span></span></code></pre></div><p>这将运行与<code>sleep</code>匹配的成绩测试。或者，您可以键入：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ make <span class=nv>GRADEFLAGS</span><span class=o>=</span>sleep grade
</span></span></code></pre></div><p>效果是一样的。</p><h3 id=实现>实现:</h3><p>首先观察<code>user/echo.c</code>、<code>user/grep.c</code>和<code>user/rm.c</code>得知命令行参数是这样获取:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span></code></pre></div><ul><li>argc 是第一个参数，表示一共获取到多少个传参</li><li>argv是第二个参数，char*型的argv[]，为字符型数组，存放命令行参数</li></ul><p>在<code>./user/user.h</code>中查看<code>sleep</code>函数的声明如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sleep</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span></code></pre></div><p>只支持一个int参数。</p><p>写出的sleep函数如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/types.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;user/user.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// no arguments or too many arguments
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>!=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;usage: grep sleep [duration]</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// use atoi convert string to int
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>sleep</span><span class=p>(</span><span class=n>atoi</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]));</span>
</span></span><span class=line><span class=cl>  <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>根据提示使用了<code>atoi</code>将字符串转换为整数</p><p><strong>注意</strong>：需要引入<code>kernel/types.h</code>,不然会有 <code>error: unknown type name 'uint'</code></p><p>在make qemu之前，要在<strong>Makefile</strong>文件中的<strong>UPROGS</strong>添加sleep，否则文件不会被编译</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>UPROGS</span><span class=o>=</span>\
</span></span><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_cat</span>\
</span></span><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_echo</span>\
</span></span><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_forktest</span>\
</span></span><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_grep</span>\
</span></span><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_init</span>\
</span></span><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_kill</span>\
</span></span><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_ln</span>\
</span></span><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_ls</span>\
</span></span><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_mkdir</span>\
</span></span><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_rm</span>\
</span></span><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_sh</span>\
</span></span><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_stressfs</span>\
</span></span><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_usertests</span>\
</span></span><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_grind</span>\
</span></span><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_wc</span>\
</span></span><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_zombie</span>\
</span></span><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_sleep</span><span class=err>\</span> <span class=err>#</span> <span class=o>&lt;-</span> <span class=err>加到这里了</span>
</span></span></code></pre></div><p>然后运行xv6进行测试，因为sleep是通过tick进行计时的，所以sleep 10会很快结束</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ make qemu
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>init: starting sh
</span></span><span class=line><span class=cl>$ sleep <span class=m>10</span>
</span></span><span class=line><span class=cl><span class=o>(</span>nothing happens <span class=k>for</span> a little <span class=k>while</span><span class=o>)</span>
</span></span><span class=line><span class=cl>$ sleep <span class=m>200</span>
</span></span><span class=line><span class=cl><span class=o>(</span>nothing happens <span class=k>for</span> a longer <span class=k>while</span><span class=o>)</span>
</span></span><span class=line><span class=cl>$ sleep
</span></span><span class=line><span class=cl>usage: grep sleep <span class=o>[</span>duration<span class=o>]</span>
</span></span><span class=line><span class=cl>$ sleep <span class=m>50</span> <span class=m>50</span>
</span></span><span class=line><span class=cl>usage: grep sleep <span class=o>[</span>duration<span class=o>]</span>
</span></span></code></pre></div><p>运行python测试后得到报错：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ./grade-lab-util sleep
</span></span><span class=line><span class=cl>/usr/bin/env: ‘python<span class=se>\r</span>’: No such file or directory
</span></span></code></pre></div><p>是编码问题，安装另外一个包解决：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo apt-get install dos2unix
</span></span><span class=line><span class=cl>dos2unix ./grade-lab-util
</span></span></code></pre></div><p>尝试运行，依然存在报错：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>/usr/bin/env: ‘python’: No such file or directory
</span></span></code></pre></div><p>安装另外一个包进行修复：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo apt install python-is-python3
</span></span></code></pre></div><p>好耶！现在跑起来完全没有问题，测试也通过了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>make: <span class=s1>&#39;kernel/kernel&#39;</span> is up to date.
</span></span><span class=line><span class=cl><span class=o>==</span> Test sleep, no <span class=nv>arguments</span> <span class=o>==</span> sleep, no arguments: OK <span class=o>(</span>2.0s<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>==</span> Test sleep, <span class=nv>returns</span> <span class=o>==</span> sleep, returns: OK <span class=o>(</span>1.1s<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>==</span> Test sleep, makes <span class=nv>syscall</span> <span class=o>==</span> sleep, makes syscall: OK <span class=o>(</span>1.1s<span class=o>)</span>
</span></span></code></pre></div><h2 id=pingpong难度easy>pingpong（难度：Easy）</h2><p>编写一个使用UNIX系统调用的程序来在两个进程之间“ping-pong”一个字节，请使用两个管道，每个方向一个。父进程应该向子进程发送一个字节;子进程应该打印“<code>&lt;pid>: received ping</code>”，其中<code>&lt;pid></code>是进程ID，并在管道中写入字节发送给父进程，然后退出;父级应该从读取从子进程而来的字节，打印“<code>&lt;pid>: received pong</code>”，然后退出。您的解决方案应该在文件<em>user/pingpong.c</em>中。</p><h3 id=提示-1>提示：</h3><ul><li><p>使用<code>pipe</code>来创造管道</p></li><li><p>使用<code>fork</code>创建子进程</p></li><li><p>使用<code>read</code>从管道中读取数据，并且使用<code>write</code>向管道中写入数据</p></li><li><p>使用<code>getpid</code>查找调用进程的进程 ID。</p></li><li><p>将程序添加到Makefile 中的<code>UPROGS</code>。</p></li><li><p>xv6 上的用户程序有一组有限的库函数可供他们使用。您可以在 <code>user/user.h</code>中看到列表；源（系统调用除外）位于<code>user/ulib.c</code>、<code>user/printf.c</code>和<code>user/umalloc.c</code>中。</p></li></ul><p>运行程序应得到下面的输出</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ make qemu
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>init: starting sh
</span></span><span class=line><span class=cl>$ pingpong
</span></span><span class=line><span class=cl>4: received ping
</span></span><span class=line><span class=cl>3: received pong
</span></span><span class=line><span class=cl>$
</span></span></code></pre></div><p>如果您的程序在两个进程之间交换一个字节并产生如上所示的输出，那么您的解决方案是正确的。</p><h3 id=实现-1>实现：</h3><p>因为需要在两个进程之间交换一个字节，而一个pipe是单向的（只能从写端到读端），所以我们需要两个pipe，一个负责从父进程写入字节，然后被子进程读取。另外一个则相反。</p><ul><li><p><strong>父进程发送ping</strong>：</p><p>他首先需要关闭从自己到子进程管道的读端，然后开始写入字节，写入完成后关闭其写端</p></li><li><p><strong>子进程接收ping</strong>：</p><p>他需要先关闭父线程到子线程的写端，然后读取字节，读取完成后关闭读端</p></li><li><p><strong>子线程发送pong</strong>:</p><p>他首先需要关闭自己到父线程管道的读端，然后开始写入字节，写入完成后关闭其写端</p></li><li><p><strong>父进程接受pong</strong>:</p><p>他需要先关闭子线程到父线程的写端，然后读取字节，读取完成后关闭读端</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#include &#34;kernel/types.h&#34;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &#34;user/user.h&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#define RD 0 // the read end of the pipe</span>
</span></span><span class=line><span class=cl><span class=c1>#define WR 1 // the write end of the pipe</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int main<span class=o>(</span>int argc, char *argv<span class=o>[])</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  int ptc<span class=o>[</span>2<span class=o>]</span>, ctp<span class=o>[</span>2<span class=o>]</span><span class=p>;</span> // <span class=m>0</span> <span class=k>for</span> read, <span class=m>1</span> <span class=k>for</span> write
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  // create pipe
</span></span><span class=line><span class=cl>  pipe<span class=o>(</span>ptc<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  pipe<span class=o>(</span>ctp<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  char <span class=nv>buf</span> <span class=o>=</span> <span class=s1>&#39;P&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  int <span class=nv>pid</span> <span class=o>=</span> fork<span class=o>()</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>do</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span>pid &gt; 0<span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      // parent
</span></span><span class=line><span class=cl>      close<span class=o>(</span>ptc<span class=o>[</span>RD<span class=o>])</span><span class=p>;</span> // close <span class=nb>read</span> end of pipe
</span></span><span class=line><span class=cl>      close<span class=o>(</span>ctp<span class=o>[</span>WR<span class=o>])</span><span class=p>;</span> // close write end of pipe
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      // send the ping to the child
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=o>(</span>write<span class=o>(</span>ptc<span class=o>[</span>WR<span class=o>]</span>, <span class=p>&amp;</span>buf, sizeof<span class=o>(</span>char<span class=o>))</span> !<span class=o>=</span> sizeof<span class=o>(</span>char<span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        fprintf<span class=o>(</span>2, <span class=s2>&#34;parent write error\n&#34;</span><span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        break<span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      // receive the pong from the child
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=o>(</span>read<span class=o>(</span>ctp<span class=o>[</span>RD<span class=o>]</span>, <span class=p>&amp;</span>buf, sizeof<span class=o>(</span>char<span class=o>))</span> !<span class=o>=</span> sizeof<span class=o>(</span>char<span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        fprintf<span class=o>(</span>2, <span class=s2>&#34;parent read error\n&#34;</span><span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        break<span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        fprintf<span class=o>(</span>1, <span class=s2>&#34;%d: received pong\n&#34;</span>, getpid<span class=o>())</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      close<span class=o>(</span>ctp<span class=o>[</span>WR<span class=o>])</span><span class=p>;</span> // close write end of pipe
</span></span><span class=line><span class=cl>      close<span class=o>(</span>ptc<span class=o>[</span>RD<span class=o>])</span><span class=p>;</span> // close <span class=nb>read</span> end of pipe
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=nv>pid</span> <span class=o>==</span> 0<span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      // child
</span></span><span class=line><span class=cl>      close<span class=o>(</span>ptc<span class=o>[</span>WR<span class=o>])</span><span class=p>;</span> // close write end of pipe
</span></span><span class=line><span class=cl>      close<span class=o>(</span>ctp<span class=o>[</span>RD<span class=o>])</span><span class=p>;</span> // close <span class=nb>read</span> end of pipe
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      // receive ping from the parent
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=o>(</span>read<span class=o>(</span>ptc<span class=o>[</span>RD<span class=o>]</span>, <span class=p>&amp;</span>buf, sizeof<span class=o>(</span>char<span class=o>)</span> !<span class=o>=</span> sizeof<span class=o>(</span>char<span class=o>)))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        fprintf<span class=o>(</span>2, <span class=s2>&#34;child read error\n&#34;</span><span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        break<span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        fprintf<span class=o>(</span>1, <span class=s2>&#34;%d: received ping\n&#34;</span>, getpid<span class=o>())</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      // send pong to the parent
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=o>(</span>write<span class=o>(</span>ctp<span class=o>[</span>WR<span class=o>]</span>, <span class=p>&amp;</span>buf, sizeof<span class=o>(</span>char<span class=o>))</span> !<span class=o>=</span> sizeof<span class=o>(</span>char<span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        fprintf<span class=o>(</span>2, <span class=s2>&#34;child write error\n&#34;</span><span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        break<span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      close<span class=o>(</span>ctp<span class=o>[</span>RD<span class=o>])</span><span class=p>;</span> // close <span class=nb>read</span> end of pipe
</span></span><span class=line><span class=cl>      close<span class=o>(</span>ptc<span class=o>[</span>WR<span class=o>])</span><span class=p>;</span> // close write end of pipe
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      break<span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    exit<span class=o>(</span>0<span class=o>)</span><span class=p>;</span> // success <span class=nb>exit</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span> <span class=k>while</span> <span class=o>(</span>0<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  // error cases
</span></span><span class=line><span class=cl>  fprintf<span class=o>(</span>2, <span class=s2>&#34;error\n&#34;</span><span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  close<span class=o>(</span>ptc<span class=o>[</span>RD<span class=o>])</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  close<span class=o>(</span>ptc<span class=o>[</span>WR<span class=o>])</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  close<span class=o>(</span>ctp<span class=o>[</span>RD<span class=o>])</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  close<span class=o>(</span>ctp<span class=o>[</span>WR<span class=o>])</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  exit<span class=o>(</span>1<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><ol><li><p><code>read(fd，buf，n)</code>系统调用从文件描述符fd读取最多n字节，将它们复制到buf，返回读取的字节数。</p></li><li><p><code>write(fd，buf，n)</code>系统调用将buf中的n字节写入文件描述符fd，并返回写入的字节数。</p></li></ol><p><strong>注</strong>：用了do和while充当try和catch</p><h2 id=primes素数难度moderatehard>Primes(素数，难度：Moderate/Hard)</h2><p>使用管道编写一个并发版本的初筛。这个想法归功于 Unix 管道的发明者 Doug McIlroy。<a href=http://swtch.com/~rsc/thread/>本页</a>中间的图片 和周围的文字说明了如何做到这一点。您的解决方案应该在文件<code>user/primes.c</code>中。</p><p>您的目标是使用<code>pipe</code>和<code>fork</code>来设置管道。第一个过程将数字 2 到 35 输入管道。对于每个素数，您将安排创建一个进程，该进程通过管道从其左邻居读取并通过另一管道向其右邻居写入。由于 xv6 的文件描述符和进程数量有限，第一个进程可以在 35 处停止。</p><p><strong>提示</strong>：</p><ul><li><p>小心关闭进程不需要的文件描述符，否则你的程序将在第一个进程达到 35 之前运行 xv6 资源不足。</p></li><li><p>一旦第一个进程达到35，它应该使用<code>wait</code>等待整个管道终止，包括所有子孙进程等等。因此，主<code>primes</code>进程应该只在打印完所有输出之后，并且在所有其他<code>primes</code>进程退出之后退出。</p><p>提示：当管道的<code>write</code>端关闭时，<code>read</code>返回零</p></li><li><p>将 32 位（4 字节）的<code>int</code>直接写入管道是最简单的，而不是使用格式化的 ASCII I/O。</p></li><li><p>您应该仅在需要时在管道中创建流程。</p></li><li><p>将程序添加到Makefile 中的<code>UPROGS</code>。</p></li></ul><p>如果您的解决方案实现了基于管道的筛选并产生以下输出，则是正确的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ make qemu
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>init: starting sh
</span></span><span class=line><span class=cl>$ primes
</span></span><span class=line><span class=cl>prime <span class=m>2</span>
</span></span><span class=line><span class=cl>prime <span class=m>3</span>
</span></span><span class=line><span class=cl>prime <span class=m>5</span>
</span></span><span class=line><span class=cl>prime <span class=m>7</span>
</span></span><span class=line><span class=cl>prime <span class=m>11</span>
</span></span><span class=line><span class=cl>prime <span class=m>13</span>
</span></span><span class=line><span class=cl>prime <span class=m>17</span>
</span></span><span class=line><span class=cl>prime <span class=m>19</span>
</span></span><span class=line><span class=cl>prime <span class=m>23</span>
</span></span><span class=line><span class=cl>prime <span class=m>29</span>
</span></span><span class=line><span class=cl>prime <span class=m>31</span>
</span></span><span class=line><span class=cl>$
</span></span></code></pre></div><p><strong>原始网页的翻译</strong>：</p><blockquote><p>考虑生成小于一千的所有素数。Eratosthenes 的筛子可以通过执行以下伪代码的流程管道来模拟：:</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>p = 从左邻居获取一个数
</span></span><span class=line><span class=cl>print p
</span></span><span class=line><span class=cl>循环：
</span></span><span class=line><span class=cl>    n =
</span></span><span class=line><span class=cl>    如果（p 不除 n）
</span></span><span class=line><span class=cl>        将 n 发送到右邻居，则从左邻居获取一个数
</span></span></code></pre></div><blockquote><p>生成进程可以将数字 2, 3, 4, &mldr;, 1000 输入管道的左端：行中的第一个进程消除 2 的倍数，第二个消除 3 的倍数，第三个消除5的倍数，以此类推：
<img src=/sieve.gif alt=示意图></p></blockquote><h3 id=实现-2>实现：</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/types.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;user/user.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define RD 0
</span></span></span><span class=line><span class=cl><span class=cp>#define WR 1
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// the child receives the primes from the parent
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>primes</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// print the first prime and return it
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>get_first_prime</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// transmit the data to the next child
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>transmit_data</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>p_next</span><span class=p>,</span> <span class=kt>int</span> <span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>p</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span> <span class=c1>// 0 for read and 1 for write
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>pipe</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=mi>35</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>write</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>WR</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>i</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;fork failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>close</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>RD</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>close</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>WR</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// child process
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>close</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>WR</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>primes</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>close</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>RD</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// parent process
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>close</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>RD</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>close</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>WR</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>wait</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>primes</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>prime_num</span> <span class=o>=</span> <span class=n>get_first_prime</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>p_next</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span> <span class=c1>// 0 for read and WR for write
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>pipe</span><span class=p>(</span><span class=n>p_next</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;fork failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// close the parent pipe
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>close</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>RD</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>close</span><span class=p>(</span><span class=n>p_next</span><span class=p>[</span><span class=n>RD</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>close</span><span class=p>(</span><span class=n>p_next</span><span class=p>[</span><span class=n>WR</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=n>WR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// child process
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>close</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>RD</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>close</span><span class=p>(</span><span class=n>p_next</span><span class=p>[</span><span class=n>WR</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>primes</span><span class=p>(</span><span class=n>p_next</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>close</span><span class=p>(</span><span class=n>p_next</span><span class=p>[</span><span class=n>RD</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// parent process
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>close</span><span class=p>(</span><span class=n>p_next</span><span class=p>[</span><span class=n>RD</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>transmit_data</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>p_next</span><span class=p>,</span> <span class=n>prime_num</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>close</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>RD</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>close</span><span class=p>(</span><span class=n>p_next</span><span class=p>[</span><span class=n>WR</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>wait</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>get_first_prime</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>RD</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>num</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>len</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// no data to read
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>close</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>RD</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;prime %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>num</span><span class=p>);</span> <span class=c1>// print the first prime number
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>num</span><span class=p>;</span> <span class=c1>// actually, the first received number must be the prime number
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>transmit_data</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>p_next</span><span class=p>,</span> <span class=kt>int</span> <span class=n>val</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// continue to read the next number
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>while</span> <span class=p>(</span><span class=n>read</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>RD</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>num</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>num</span> <span class=o>%</span> <span class=n>val</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>write</span><span class=p>(</span><span class=n>p_next</span><span class=p>[</span><span class=n>WR</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>num</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span> <span class=c1>// only write the prime number
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>注</strong>：其实就是使用递归新建管道，然后筛出符合条件的数，再传到子进程里</p><h3 id=更新>更新：</h3><p>之前的实现写的有点长了，更新一个短一点的mini版</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/types.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;user/user.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 0 for read and 1 for write
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define RD 0
</span></span></span><span class=line><span class=cl><span class=cp>#define WR 1
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>primes</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>p</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>pipe</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>fork</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// child process
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>primes</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=c1>// parent process
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>close</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>RD</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=mi>35</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>write</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>WR</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>i</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>close</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>WR</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>wait</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>primes</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>prime</span><span class=p>,</span> <span class=n>num</span><span class=p>,</span> <span class=n>p_next</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>close</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>WR</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>read</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>RD</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>prime</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>close</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>RD</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;prime %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>prime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>pipe</span><span class=p>(</span><span class=n>p_next</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>fork</span><span class=p>()</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// parent process
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>close</span><span class=p>(</span><span class=n>p_next</span><span class=p>[</span><span class=n>RD</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>read</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>RD</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>num</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>num</span> <span class=o>%</span> <span class=n>prime</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>write</span><span class=p>(</span><span class=n>p_next</span><span class=p>[</span><span class=n>WR</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>num</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>close</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>RD</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>close</span><span class=p>(</span><span class=n>p_next</span><span class=p>[</span><span class=n>WR</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>wait</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=c1>// child process
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>primes</span><span class=p>(</span><span class=n>p_next</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>close</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>RD</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=find难度moderate>find（难度：Moderate）</h2><p>写一个简化版本的UNIX的<code>find</code>程序：查找目录树中具有特定名称的所有文件，你的解决方案应该放在<em>user/find.c</em></p><h3 id=提示-2>提示：</h3><ul><li>查看<em><strong>user/ls.c</strong></em>文件学习如何读取目录</li><li>使用递归允许<code>find</code>下降到子目录中</li><li>不要在<code>.</code>和<code>..</code>目录中递归</li><li>对文件系统的更改会在qemu的运行过程中一直保持；要获得一个干净的文件系统，请运行<code>make clean</code>，然后<code>make qemu</code></li><li>你将会使用到C语言的字符串，要学习它请看《C程序设计语言》（K&R）,例如第5.5节</li><li>注意在C语言中不能像python一样使用“<code>==</code>”对字符串进行比较，而应当使用<code>strcmp()</code></li><li>将程序加入到Makefile的<code>UPROGS</code></li></ul><p>如果你的程序输出下面的内容，那么它是正确的（当文件系统中包含文件<em><strong>b</strong></em>和<em><strong>a/b</strong></em>的时候）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ make qemu
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>init: starting sh
</span></span><span class=line><span class=cl>$ <span class=nb>echo</span> &gt; b
</span></span><span class=line><span class=cl>$ mkdir a
</span></span><span class=line><span class=cl>$ <span class=nb>echo</span> &gt; a/b
</span></span><span class=line><span class=cl>$ find . b
</span></span><span class=line><span class=cl>./b
</span></span><span class=line><span class=cl>./a/b
</span></span><span class=line><span class=cl>$
</span></span></code></pre></div><h3 id=实现-3>实现：</h3><p>首先在主程序里面判断一下参数数量，然后find函数里面先检查一下存不存在，能不能获取stat，是不是dir，以及路径是否过长。通过测试之后，我们就能用while loop不断读取。如果当前目录是空的就直接返回，不然先把名字加到buf里面，然后读取stat。如果不能读取就下一个文件，当找到符合文件名字的时候直接打印。（因为刚刚已经把名字更新到buf内了）如果遇到文件夹就递归查询，同时注意不要在<code>.</code>和<code>..</code>目录中递归</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/types.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/stat.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;user/user.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/fs.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>find</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>fileName</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>512</span><span class=p>],</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>dirent</span> <span class=n>de</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>stat</span> <span class=n>st</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>((</span><span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;ls: cannot open %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>fstat</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>st</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;ls: cannot stat %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>st</span><span class=p>.</span><span class=n>type</span> <span class=o>!=</span> <span class=n>T_DIR</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;find: %s is not a directory !</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>strlen</span><span class=p>(</span><span class=n>path</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>+</span> <span class=n>DIRSIZ</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&gt;</span> <span class=k>sizeof</span> <span class=n>buf</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;find: path too long</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// add the &#39;/&#39; to the path end
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>strcpy</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=n>path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span> <span class=o>=</span> <span class=n>buf</span> <span class=o>+</span> <span class=n>strlen</span><span class=p>(</span><span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=n>p</span><span class=o>++</span> <span class=o>=</span> <span class=sc>&#39;/&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=n>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>de</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>de</span><span class=p>))</span> <span class=o>==</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>de</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>de</span><span class=p>.</span><span class=n>inum</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>memmove</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>de</span><span class=p>.</span><span class=n>name</span><span class=p>,</span> <span class=n>DIRSIZ</span><span class=p>);</span> <span class=c1>// copy the name to the buffer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>p</span><span class=p>[</span><span class=n>DIRSIZ</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>               <span class=c1>// add the null terminator
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>stat</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>st</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;find: cannot stat %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>strcmp</span><span class=p>(</span><span class=n>de</span><span class=p>.</span><span class=n>name</span><span class=p>,</span> <span class=n>fileName</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>st</span><span class=p>.</span><span class=n>type</span> <span class=o>==</span> <span class=n>T_DIR</span> <span class=o>&amp;&amp;</span> <span class=n>strcmp</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=s>&#34;.&#34;</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>               <span class=n>strcmp</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=s>&#34;..&#34;</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// do not recurse into the current directory or the parent directory
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>find</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=n>fileName</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>==</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>find</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>argv</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;usage: fing &lt;PATH&gt; &lt;FILENAME&gt;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>注：这部分有点不太理解，几个方法和结构体不是很熟悉，学习完文件系统再回头看这部分</p><h2 id=xargs难度moderate>xargs（难度：Moderate）</h2><p>编写一个简化版UNIX的<code>xargs</code>程序：它从标准输入中按行读取，并且为每一行执行一个命令，将行作为参数提供给命令。你的解决方案应该在<em><strong>user/xargs.c</strong></em></p><p>下面的例子解释了<code>xargs</code>的行为</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ <span class=nb>echo</span> hello too <span class=p>|</span> xargs <span class=nb>echo</span> bye
</span></span><span class=line><span class=cl>bye hello too
</span></span><span class=line><span class=cl>$
</span></span></code></pre></div><p>注意，这里的命令是<code>echo bye</code>，额外的参数是<code>hello too</code>，这样就组成了命令<code>echo bye hello too</code>，此命令输出<code>bye hello too</code></p><p>请注意，UNIX上的<code>xargs</code>进行了优化，一次可以向该命令提供更多的参数。 我们不需要您进行此优化。 要使UNIX上的<code>xargs</code>表现出本实验所实现的方式，请将<code>-n</code>选项设置为1。例如</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ <span class=nb>echo</span> <span class=s2>&#34;1\n2&#34;</span> <span class=p>|</span> xargs -n <span class=m>1</span> <span class=nb>echo</span> line
</span></span><span class=line><span class=cl>line <span class=m>1</span>
</span></span><span class=line><span class=cl>line <span class=m>2</span>
</span></span><span class=line><span class=cl>$
</span></span></code></pre></div><h3 id=提示-3>提示：</h3><ul><li>使用<code>fork</code>和<code>exec</code>对每行输入调用命令，在父进程中使用<code>wait</code>等待子进程完成命令。</li><li>要读取单个输入行，请一次读取一个字符，直到出现换行符（&rsquo;\n&rsquo;）。</li><li><em><strong>kernel/param.h</strong></em>声明<code>MAXARG</code>，如果需要声明<code>argv</code>数组，这可能很有用。</li><li>将程序添加到<em><strong>Makefile</strong></em>中的<code>UPROGS</code>。</li><li>对文件系统的更改会在qemu的运行过程中保持不变；要获得一个干净的文件系统，请运行<code>make clean</code>，然后<code>make qemu</code></li></ul><p><code>xargs</code>、<code>find</code>和<code>grep</code>结合得很好</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ find . b <span class=p>|</span> xargs grep hello
</span></span></code></pre></div><p>将对“<code>.</code>”下面的目录中名为<em><strong>b</strong></em>的每个文件运行<code>grep hello</code>。</p><p>要测试您的<code>xargs</code>方案是否正确，请运行shell脚本<em><strong>xargstest.sh</strong></em>。如果您的解决方案产生以下输出，则是正确的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ make qemu
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>init: starting sh
</span></span><span class=line><span class=cl>$ sh &lt; xargstest.sh
</span></span><span class=line><span class=cl>$ $ $ $ $ $ hello
</span></span><span class=line><span class=cl>hello
</span></span><span class=line><span class=cl>hello
</span></span><span class=line><span class=cl>$ $
</span></span></code></pre></div><p>你可能不得不回去修复你的<code>find</code>程序中的bug。输出有许多<code>$</code>，因为xv6 shell没有意识到它正在处理来自文件而不是控制台的命令，并为文件中的每个命令打印<code>$</code>。</p><h3 id=实现-4>实现：</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/types.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/param.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;user/user.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define MAXSZ 512
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=n>state</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>S_WAIT</span><span class=p>,</span>         <span class=c1>// the initial state, or the current is a space
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>S_ARG</span><span class=p>,</span>          <span class=c1>// the current char is a arg
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>S_ARG_END</span><span class=p>,</span>      <span class=c1>// the end of the arg
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>S_ARG_LINE_END</span><span class=p>,</span> <span class=c1>// new line next to the arg, &#34;abc\n&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>S_LINE_END</span><span class=p>,</span>     <span class=c1>// the new line next to the space, &#34;abc \n&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>S_END</span><span class=p>,</span>          <span class=c1>// end, EOF
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=n>char_type</span> <span class=p>{</span> <span class=n>C_SPACE</span><span class=p>,</span> <span class=n>C_CHAR</span><span class=p>,</span> <span class=n>C_LINE_END</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=n>char_type</span> <span class=nf>get_char_type</span><span class=p>(</span><span class=kt>char</span> <span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>switch</span> <span class=p>(</span><span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=sc>&#39; &#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>C_SPACE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=sc>&#39;\n&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>C_LINE_END</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>C_CHAR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=n>state</span> <span class=nf>transform_state</span><span class=p>(</span><span class=k>enum</span> <span class=n>state</span> <span class=n>cur</span><span class=p>,</span> <span class=k>enum</span> <span class=n>char_type</span> <span class=n>ct</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>switch</span> <span class=p>(</span><span class=n>cur</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=nl>S_WAIT</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ct</span> <span class=o>==</span> <span class=n>C_SPACE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>S_WAIT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ct</span> <span class=o>==</span> <span class=n>C_LINE_END</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>S_LINE_END</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ct</span> <span class=o>==</span> <span class=n>C_CHAR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>S_ARG</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=nl>S_ARG</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ct</span> <span class=o>==</span> <span class=n>C_SPACE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>S_ARG_END</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ct</span> <span class=o>==</span> <span class=n>C_LINE_END</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>S_ARG_LINE_END</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ct</span> <span class=o>==</span> <span class=n>C_CHAR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>S_ARG</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=nl>S_ARG_END</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=nl>S_ARG_LINE_END</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=nl>S_LINE_END</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ct</span> <span class=o>==</span> <span class=n>C_SPACE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>S_WAIT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ct</span> <span class=o>==</span> <span class=n>C_LINE_END</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>S_LINE_END</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ct</span> <span class=o>==</span> <span class=n>C_CHAR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>S_ARG</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>S_END</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>clearArgv</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>x_argv</span><span class=p>[</span><span class=n>MAXARG</span><span class=p>],</span> <span class=kt>int</span> <span class=n>beg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>beg</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>MAXARG</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>x_argv</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;xargs: minium amount of args is 2 !</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>&gt;=</span> <span class=n>MAXARG</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;xargs: maxium amount of args is %d !</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>MAXARG</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>lines</span><span class=p>[</span><span class=n>MAXSZ</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>lines</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>x_argv</span><span class=p>[</span><span class=n>MAXARG</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span> <span class=c1>// used to store the args
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// record all the args
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// start 1 for skip the first space
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>argc</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>x_argv</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>argv</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>start</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>end</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>current</span> <span class=o>=</span> <span class=n>argc</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>enum</span> <span class=n>state</span> <span class=n>st</span> <span class=o>=</span> <span class=n>S_WAIT</span><span class=p>;</span> <span class=c1>// the initial state
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=n>st</span> <span class=o>!=</span> <span class=n>S_END</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>p</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>))</span> <span class=o>!=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>st</span> <span class=o>=</span> <span class=n>S_END</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>st</span> <span class=o>=</span> <span class=n>transform_state</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>get_char_type</span><span class=p>(</span><span class=o>*</span><span class=n>p</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>++</span><span class=n>end</span> <span class=o>&gt;=</span> <span class=n>MAXSZ</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;xargs: arguments too long.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>st</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>S_WAIT</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=o>++</span><span class=n>start</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>S_ARG_END</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>x_argv</span><span class=p>[</span><span class=n>current</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>lines</span><span class=p>[</span><span class=n>start</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=n>start</span> <span class=o>=</span> <span class=n>end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>S_ARG_LINE_END</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>x_argv</span><span class=p>[</span><span class=n>current</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>lines</span><span class=p>[</span><span class=n>start</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>S_LINE_END</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>start</span> <span class=o>=</span> <span class=n>end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>fork</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exec</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>x_argv</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=n>current</span> <span class=o>=</span> <span class=n>argc</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>clearArgv</span><span class=p>(</span><span class=n>x_argv</span><span class=p>,</span> <span class=n>current</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>wait</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>++</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>注</strong>：这部分是用了状态机，感觉跟之前写编译器的时候很像，有种莫名既视感。这部分也需要回头看一下</p></div><div class=post_footer><div class=meta><div class=info><span class="field tags"><i class=ri-stack-line></i>
<a href=https://yzhe819.github.io/tags/%E4%B8%AD%E6%96%87/>中文</a>
<a href=https://yzhe819.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a>
<a href=https://yzhe819.github.io/tags/6.s081/>6.S081</a></span></div></div></div></div><div class=doc_comments></div></div></div></div><a id=back_to_top href=# class=back_to_top><i class=ri-arrow-up-s-line></i></a><footer class=footer><div class=powered_by><a href=https://varkai.com>Designed by VarKai,</a>
<a href=http://www.gohugo.io/>Proudly published with Hugo</a></div><div class=footer_slogan><span></span></div></footer><script src=https://yzhe819.github.io/js/jquery-3.5.1.min.js></script>
<link href=https://yzhe819.github.io/css/fancybox.min.css rel=stylesheet><script src=https://yzhe819.github.io/js/fancybox.min.js></script>
<script src=https://yzhe819.github.io/js/zozo.js></script>
<script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style></body></html>