<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="yzhe819"><title>MIT 6.S081 Lab 3 页表 ｜ yzhe819</title><meta name=description content=" 本篇文章是第三个lab的记录
官网链接：Lab: Page tables
代码仓库：Github
"><meta name=keywords content="yzhe819,zozo"><link rel="shortcut icon" href=https://yzhe819.github.io/images/favicon.ico><link rel=stylesheet type=text/css media=screen href=https://yzhe819.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css><link rel=stylesheet type=text/css media=screen href=https://yzhe819.github.io/css/zozo.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css><link rel=stylesheet type=text/css media=screen href=https://yzhe819.github.io/css/highlight.css></head><body><div class="main animate__animated animate__fadeInDown"><div class="nav_container animated fadeInDown"><div class=site_nav id=site_nav><ul><li><a href=/>Home</a></li><li><a href=/posts/>Archive</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul></div><div class=menu_icon><a id=menu_icon><i class=ri-menu-line></i></a></div></div><div class="header animated fadeInDown"><div class=site_title_container><div class=site_title><h1><a href=https://yzhe819.github.io/><span>yzhe819</span></a></h1></div><div class=description><p class=sub_title>yzhe819's Blog</p><div class=my_socials><a href=https://github.com/yzhe819 title=github target=_blank><i class=ri-github-fill></i></a>
<a href=https://yzhe819.github.io/index.xml type=application/rss+xml title=rss target=_blank><i class=ri-rss-fill></i></a></div></div></div></div><div class=content><div class=post_page><div class="post animate__animated animate__fadeInDown"><div class="post_title post_detail_title"><h2><a href=/posts/mit-6.s081.lab-3/>MIT 6.S081 Lab 3 页表</a></h2><span class=date>2022.06.19</span></div><div class="post_content markdown"><blockquote><p>本篇文章是第三个lab的记录</p></blockquote><p>官网链接：<a href=https://pdos.csail.mit.edu/6.828/2020/labs/pgtbl.html>Lab: Page tables</a></p><p>代码仓库：<a href=https://github.com/yzhe819/MIT-6.S081/tree/pgtbl>Github</a></p><h2 id=打印页表easy>打印页表（easy）</h2><p>为了帮助您了解RISC-V页表，也许为了帮助将来的调试，您的第一个任务是编写一个打印页表内容的函数。</p><p>定义一个名为<code>vmprint()</code>的函数。它应当接收一个<code>pagetable_t</code>作为参数，并以下面描述的格式打印该页表。在<code>exec.c</code>中的<code>return argc</code>之前插入<code>if(p->pid==1) vmprint(p->pagetable)</code>，以打印第一个进程的页表。如果你通过了<code>pte printout</code>测试的<code>make grade</code>，你将获得此作业的满分。</p><p>现在，当您启动xv6时，它应该像这样打印输出来描述第一个进程刚刚完成<code>exec()</code>ing<code>init</code>时的页表：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>page table 0x0000000087f6e000
</span></span><span class=line><span class=cl>..0: pte 0x0000000021fda801 pa 0x0000000087f6a000
</span></span><span class=line><span class=cl>.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000
</span></span><span class=line><span class=cl>.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000
</span></span><span class=line><span class=cl>.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000
</span></span><span class=line><span class=cl>.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000
</span></span><span class=line><span class=cl>..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000
</span></span><span class=line><span class=cl>.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000
</span></span><span class=line><span class=cl>.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000
</span></span><span class=line><span class=cl>.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000
</span></span></code></pre></div><p>第一行显示<code>vmprint</code>的参数。之后的每行对应一个PTE，包含树中指向页表页的PTE。每个PTE行都有一些“<code>..</code>”的缩进表明它在树中的深度。每个PTE行显示其在页表页中的PTE索引、PTE比特位以及从PTE提取的物理地址。不要打印无效的PTE。在上面的示例中，顶级页表页具有条目0和255的映射。条目0的下一级只映射了索引0，该索引0的下一级映射了条目0、1和2。</p><p>您的代码可能会发出与上面显示的不同的物理地址。条目数和虚拟地址应相同。</p><h3 id=提示>提示：</h3><ul><li>你可以将<code>vmprint()</code>放在<strong>kernel/vm.c</strong>中</li><li>使用定义在<strong>kernel/riscv.h</strong>末尾处的宏</li><li>函数<code>freewalk</code>可能会对你有所启发</li><li>将<code>vmprint</code>的原型定义在<strong>kernel/defs.h</strong>中，这样你就可以在<code>exec.c</code>中调用它了</li><li>在你的<code>printf</code>调用中使用<code>%p</code>来打印像上面示例中的完成的64比特的十六进制PTE和地址</li></ul><h3 id=实现>实现：</h3><p>观察一下函数<code>freewalk</code>，主要逻辑为历遍整页表（一共512项）然后通过<code>PTE_V</code>找出里面有效的页表项。 因为最后一层页表中页表项中W位，R位，X位起码有一位会被设置为1，所以<code>(pte & (PTE_R|PTE_W|PTE_X)) == 0</code>表示不是最后一层的页表。可以继续开始递归。因为所有的子页表已经被清空了，如果找到不符合这个条件的会报错<code>"freewalk: leaf"</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Recursively free page-table pages.
</span></span></span><span class=line><span class=cl><span class=c1>// All leaf mappings must already have been removed.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>freewalk</span><span class=p>(</span><span class=n>pagetable_t</span> <span class=n>pagetable</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// there are 2^9 = 512 PTEs in a page table.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>512</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>pte_t</span> <span class=n>pte</span> <span class=o>=</span> <span class=n>pagetable</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_V</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>PTE_R</span><span class=o>|</span><span class=n>PTE_W</span><span class=o>|</span><span class=n>PTE_X</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=c1>// this PTE points to a lower-level page table.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>uint64</span> <span class=n>child</span> <span class=o>=</span> <span class=n>PTE2PA</span><span class=p>(</span><span class=n>pte</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>freewalk</span><span class=p>((</span><span class=n>pagetable_t</span><span class=p>)</span><span class=n>child</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>pagetable</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_V</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=n>panic</span><span class=p>(</span><span class=s>&#34;freewalk: leaf&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>kfree</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>pagetable</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>所以开始写一个简单的递归函数。对于每一个有效的页表项都打印其和其子项的内容。如果不是最后一层的页表就继续递归，以及打印层次加一。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>_vmprint</span><span class=p>(</span><span class=n>pagetable_t</span> <span class=n>pagetable</span><span class=p>,</span> <span class=kt>int</span> <span class=n>level</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=c1>// there are 2^9 = 512 PTEs in a page table.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>512</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>pte_t</span> <span class=n>pte</span> <span class=o>=</span> <span class=n>pagetable</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=c1>// PTE_V is a flag for whether the page table is valid
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_V</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>level</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>j</span><span class=p>)</span> <span class=n>printf</span><span class=p>(</span><span class=s>&#34; &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;..&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=n>uint64</span> <span class=n>child</span> <span class=o>=</span> <span class=n>PTE2PA</span><span class=p>(</span><span class=n>pte</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%d: pte %p pa %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>pte</span><span class=p>,</span> <span class=n>child</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span><span class=p>((</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>PTE_R</span><span class=o>|</span><span class=n>PTE_W</span><span class=o>|</span><span class=n>PTE_X</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=c1>// this PTE points to a lower-level page table.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>_vmprint</span><span class=p>((</span><span class=n>pagetable_t</span><span class=p>)</span><span class=n>child</span><span class=p>,</span> <span class=n>level</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>vmprint</span><span class=p>(</span><span class=n>pagetable_t</span> <span class=n>pagetable</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;page table %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pagetable</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>_vmprint</span><span class=p>(</span><span class=n>pagetable</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=每个进程的内核页表hard>每个进程的内核页表（hard）</h2><p>Xv6有一个单独的用于在内核中执行程序时的内核页表。内核页表直接映射（恒等映射）到物理地址，也就是说内核虚拟地址<code>x</code>映射到物理地址仍然是<code>x</code>。Xv6还为每个进程的用户地址空间提供了一个单独的页表，只包含该进程用户内存的映射，从虚拟地址0开始。因为内核页表不包含这些映射，所以用户地址在内核中无效。因此，当内核需要使用在系统调用中传递的用户指针（例如，传递给<code>write()</code>的缓冲区指针）时，内核必须首先将指针转换为物理地址。本节和下一节的目标是允许内核直接解引用用户指针。</p><p>你的第一项工作是修改内核来让每一个进程在内核中执行时使用它自己的内核页表的副本。修改<code>struct proc</code>来为每一个进程维护一个内核页表，修改调度程序使得切换进程时也切换内核页表。对于这个步骤，每个进程的内核页表都应当与现有的的全局内核页表完全一致。如果你的<code>usertests</code>程序正确运行了，那么你就通过了这个实验。</p><p>阅读本作业开头提到的章节和代码；了解虚拟内存代码的工作原理后，正确修改虚拟内存代码将更容易。页表设置中的错误可能会由于缺少映射而导致陷阱，可能会导致加载和存储影响到意料之外的物理页存页面，并且可能会导致执行来自错误内存页的指令。</p><h3 id=提示-1>提示：</h3><ul><li>在<code>struct proc</code>中为进程的内核页表增加一个字段</li><li>为一个新进程生成一个内核页表的合理方案是实现一个修改版的<code>kvminit</code>，这个版本中应当创造一个新的页表而不是修改<code>kernel_pagetable</code>。你将会考虑在<code>allocproc</code>中调用这个函数</li><li>确保每一个进程的内核页表都关于该进程的内核栈有一个映射。在未修改的XV6中，所有的内核栈都在<code>procinit</code>中设置。你将要把这个功能部分或全部的迁移到<code>allocproc</code>中</li><li>修改<code>scheduler()</code>来加载进程的内核页表到核心的<code>satp</code>寄存器(参阅<code>kvminithart</code>来获取启发)。不要忘记在调用完<code>w_satp()</code>后调用<code>sfence_vma()</code></li><li>没有进程运行时<code>scheduler()</code>应当使用<code>kernel_pagetable</code></li><li>在<code>freeproc</code>中释放一个进程的内核页表</li><li>你需要一种方法来释放页表，而不必释放叶子物理内存页面。</li><li>调式页表时，也许<code>vmprint</code>能派上用场</li><li>修改XV6本来的函数或新增函数都是允许的；你或许至少需要在<strong>kernel/vm.c</strong>和<strong>kernel/proc.c</strong>中这样做（但不要修改<strong>kernel/vmcopyin.c</strong>, <strong>kernel/stats.c</strong>, <strong>user/usertests.c</strong>, 和<strong>user/stats.c</strong>）</li><li>页表映射丢失很可能导致内核遭遇页面错误。这将导致打印一段包含<code>sepc=0x00000000XXXXXXXX</code>的错误提示。你可以在<strong>kernel/kernel.asm</strong>通过查询<code>XXXXXXXX</code>来定位错误。</li></ul><h3 id=实现-1>实现：</h3><p>第一步，首先给proc.h里面的<code>struct proc</code>加上内核页表的字段</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>proc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>spinlock</span> <span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// p-&gt;lock must be held when using these:
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>enum</span> <span class=n>procstate</span> <span class=n>state</span><span class=p>;</span>        <span class=c1>// Process state
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>parent</span><span class=p>;</span>         <span class=c1>// Parent process
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=o>*</span><span class=n>chan</span><span class=p>;</span>                  <span class=c1>// If non-zero, sleeping on chan
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>killed</span><span class=p>;</span>                  <span class=c1>// If non-zero, have been killed
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>xstate</span><span class=p>;</span>                  <span class=c1>// Exit status to be returned to parent&#39;s wait
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>pid</span><span class=p>;</span>                     <span class=c1>// Process ID
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// these are private to the process, so p-&gt;lock need not be held.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint64</span> <span class=n>kstack</span><span class=p>;</span>               <span class=c1>// Virtual address of kernel stack
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint64</span> <span class=n>sz</span><span class=p>;</span>                   <span class=c1>// Size of process memory (bytes)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>pagetable_t</span> <span class=n>pagetable</span><span class=p>;</span>       <span class=c1>// User page table
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>pagetable_t</span> <span class=n>kernelpt</span><span class=p>;</span>        <span class=c1>// Kernel page table
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>trapframe</span> <span class=o>*</span><span class=n>trapframe</span><span class=p>;</span> <span class=c1>// data page for trampoline.S
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>context</span> <span class=n>context</span><span class=p>;</span>      <span class=c1>// swtch() here to run process
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>ofile</span><span class=p>[</span><span class=n>NOFILE</span><span class=p>];</span>  <span class=c1>// Open files
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>cwd</span><span class=p>;</span>           <span class=c1>// Current directory
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>char</span> <span class=n>name</span><span class=p>[</span><span class=mi>16</span><span class=p>];</span>               <span class=c1>// Process name (debugging)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>第二步，在<code>vm.c</code>中添加新的方法<code>proc_kpt_init</code>，该方法用于在<code>allocproc</code> 中初始化进程的内核页表。这个函数还需要一个辅助函数<code>uvmmap</code>，该函数和<code>kvmmap</code>方法几乎一致，不同的是<code>kvmmap</code>是对整体的内核页表进行映射，而<code>uvmmap</code>是对给定的内核页表进行映射。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Just follow the kvmmap on vm.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>uvmmap</span><span class=p>(</span><span class=n>pagetable_t</span> <span class=n>pagetable</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>va</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>pa</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>sz</span><span class=p>,</span> <span class=kt>int</span> <span class=n>perm</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>mappages</span><span class=p>(</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>va</span><span class=p>,</span> <span class=n>sz</span><span class=p>,</span> <span class=n>pa</span><span class=p>,</span> <span class=n>perm</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>panic</span><span class=p>(</span><span class=s>&#34;uvmmap&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Create a kernel page table for the process
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pagetable_t</span>
</span></span><span class=line><span class=cl><span class=nf>proc_kpt_init</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>  <span class=n>pagetable_t</span> <span class=n>kernelpt</span> <span class=o>=</span> <span class=n>uvmcreate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>kernelpt</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uvmmap</span><span class=p>(</span><span class=n>kernelpt</span><span class=p>,</span> <span class=n>UART0</span><span class=p>,</span> <span class=n>UART0</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>uvmmap</span><span class=p>(</span><span class=n>kernelpt</span><span class=p>,</span> <span class=n>VIRTIO0</span><span class=p>,</span> <span class=n>VIRTIO0</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>uvmmap</span><span class=p>(</span><span class=n>kernelpt</span><span class=p>,</span> <span class=n>CLINT</span><span class=p>,</span> <span class=n>CLINT</span><span class=p>,</span> <span class=mh>0x10000</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>uvmmap</span><span class=p>(</span><span class=n>kernelpt</span><span class=p>,</span> <span class=n>PLIC</span><span class=p>,</span> <span class=n>PLIC</span><span class=p>,</span> <span class=mh>0x400000</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>uvmmap</span><span class=p>(</span><span class=n>kernelpt</span><span class=p>,</span> <span class=n>KERNBASE</span><span class=p>,</span> <span class=n>KERNBASE</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>etext</span><span class=o>-</span><span class=n>KERNBASE</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_X</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>uvmmap</span><span class=p>(</span><span class=n>kernelpt</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>etext</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>etext</span><span class=p>,</span> <span class=n>PHYSTOP</span><span class=o>-</span><span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>etext</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>uvmmap</span><span class=p>(</span><span class=n>kernelpt</span><span class=p>,</span> <span class=n>TRAMPOLINE</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>trampoline</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_X</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>kernelpt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>然后在allocproc里面调用</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c1>// An empty user page table.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span> <span class=o>=</span> <span class=n>proc_pagetable</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>freeproc</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Add the kernal page table
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernelpt</span> <span class=o>=</span> <span class=n>proc_kpt_init</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernelpt</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>freeproc</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></div><p>第三步，根据提示，为了确保每一个进程的内核页表都关于该进程的内核栈有一个映射。我们需要将<code>procinit</code>方法中相关的代码迁移到<code>allocproc</code>方法中。很明显就是下面这段代码，将其剪切到上述内核页表初始化的代码后。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Allocate a page for the process&#39;s kernel stack.
</span></span></span><span class=line><span class=cl><span class=c1>// Map it high in memory, followed by an invalid
</span></span></span><span class=line><span class=cl><span class=c1>// guard page.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=o>*</span><span class=n>pa</span> <span class=o>=</span> <span class=n>kalloc</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=n>pa</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>panic</span><span class=p>(</span><span class=s>&#34;kalloc&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>uint64</span> <span class=n>va</span> <span class=o>=</span> <span class=n>KSTACK</span><span class=p>((</span><span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=n>p</span> <span class=o>-</span> <span class=n>proc</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>uvmmap</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernelpt</span><span class=p>,</span> <span class=n>va</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>pa</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>-&gt;</span><span class=n>kstack</span> <span class=o>=</span> <span class=n>va</span><span class=p>;</span>
</span></span></code></pre></div><p>第四步，我们需要修改<code>scheduler()</code>来加载进程的内核页表到SATP寄存器。提示里面请求阅读kvminithart。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Switch h/w page table register to the kernel&#39;s page table,
</span></span></span><span class=line><span class=cl><span class=c1>// and enable paging.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>kvminithart</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>w_satp</span><span class=p>(</span><span class=n>MAKE_SATP</span><span class=p>(</span><span class=n>kernel_pagetable</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=n>sfence_vma</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>kvminithart</code>是用于原先的内核页表，我们将进程的内核页表传进去就可以。在vm.c里面添加一个新方法<code>proc_inithart</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Store kernel page table to SATP register
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>proc_inithart</span><span class=p>(</span><span class=n>pagetable_t</span> <span class=n>kpt</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>w_satp</span><span class=p>(</span><span class=n>MAKE_SATP</span><span class=p>(</span><span class=n>kpt</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=n>sfence_vma</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>然后在scheduler()内调用即可，但方法结束的时候，记得切换会一开始的kernel_pagetable。（调用上面的kvminithart就能做到</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>-&gt;</span><span class=n>state</span> <span class=o>=</span> <span class=n>RUNNING</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>c</span><span class=o>-&gt;</span><span class=n>proc</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Store the kernal page table into the SATP
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>proc_inithart</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernelpt</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>swtch</span><span class=p>(</span><span class=o>&amp;</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>context</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Come back to the global kernel page table
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>kvminithart</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></div><p>第五步，在<code>freeproc</code>中释放一个进程的内核页表。首先释放页表内的内核栈，调用uvmunmap可以解除映射，最后的一个参数（do_free）为一的时候，会释放实际内存。然后调用<code>proc.c</code>里面新加的<code>proc_freekernelpt</code>释放内核页表。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// free the kernel stack in the RAM
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>uvmunmap</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernelpt</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>kstack</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>-&gt;</span><span class=n>kstack</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// free the kernel page table of process
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernelpt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>proc_freekernelpt</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernelpt</span><span class=p>);</span>
</span></span></code></pre></div><p>调用的proc_freekernelpt方法如下，历遍整个内核页表，然后将所有有效的页表项清空为零。如果这个页表项不在最后一层的页表上，需要继续进行递归。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>proc_freekernelpt</span><span class=p>(</span><span class=n>pagetable_t</span> <span class=n>kernelpt</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// similar to the freewalk method
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// there are 2^9 = 512 PTEs in a page table.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>512</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>pte_t</span> <span class=n>pte</span> <span class=o>=</span> <span class=n>kernelpt</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_V</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=n>kernelpt</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>((</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>PTE_R</span><span class=o>|</span><span class=n>PTE_W</span><span class=o>|</span><span class=n>PTE_X</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>uint64</span> <span class=n>child</span> <span class=o>=</span> <span class=n>PTE2PA</span><span class=p>(</span><span class=n>pte</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>proc_freekernelpt</span><span class=p>((</span><span class=n>pagetable_t</span><span class=p>)</span><span class=n>child</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>kfree</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>kernelpt</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>第六步，将需要的函数定义添加到 <code>kernel/defs.h</code> 中</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// vm.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span>            <span class=nf>kvminit</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>pagetable_t</span>     <span class=nf>proc_kpt_init</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span> <span class=c1>// 用于内核页表的初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span>            <span class=nf>kvminithart</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span> 
</span></span><span class=line><span class=cl><span class=kt>void</span>            <span class=nf>proc_inithart</span><span class=p>(</span><span class=n>pagetable_t</span><span class=p>);</span> <span class=c1>// 将进程的内核页表保存到SATP寄存器
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>uint64</span>          <span class=nf>kvmpa</span><span class=p>(</span><span class=n>uint64</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span>            <span class=nf>kvmmap</span><span class=p>(</span><span class=n>uint64</span><span class=p>,</span> <span class=n>uint64</span><span class=p>,</span> <span class=n>uint64</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span>            <span class=nf>uvmmap</span><span class=p>(</span><span class=n>pagetable_t</span><span class=p>,</span> <span class=n>uint64</span><span class=p>,</span> <span class=n>uint64</span><span class=p>,</span> <span class=n>uint64</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span>             <span class=nf>mappages</span><span class=p>(</span><span class=n>pagetable_t</span><span class=p>,</span> <span class=n>uint64</span><span class=p>,</span> <span class=n>uint64</span><span class=p>,</span> <span class=n>uint64</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>pagetable_t</span>     <span class=nf>uvmcreate</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span>            <span class=nf>uvminit</span><span class=p>(</span><span class=n>pagetable_t</span><span class=p>,</span> <span class=n>uchar</span> <span class=o>*</span><span class=p>,</span> <span class=n>uint</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>uint64</span>          <span class=nf>uvmalloc</span><span class=p>(</span><span class=n>pagetable_t</span><span class=p>,</span> <span class=n>uint64</span><span class=p>,</span> <span class=n>uint64</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>uint64</span>          <span class=nf>uvmdealloc</span><span class=p>(</span><span class=n>pagetable_t</span><span class=p>,</span> <span class=n>uint64</span><span class=p>,</span> <span class=n>uint64</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef SOL_COW
</span></span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span>             <span class=nf>uvmcopy</span><span class=p>(</span><span class=n>pagetable_t</span><span class=p>,</span> <span class=n>pagetable_t</span><span class=p>,</span> <span class=n>uint64</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span>            <span class=nf>uvmfree</span><span class=p>(</span><span class=n>pagetable_t</span><span class=p>,</span> <span class=n>uint64</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span>            <span class=nf>uvmunmap</span><span class=p>(</span><span class=n>pagetable_t</span><span class=p>,</span> <span class=n>uint64</span><span class=p>,</span> <span class=n>uint64</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span>            <span class=nf>uvmclear</span><span class=p>(</span><span class=n>pagetable_t</span><span class=p>,</span> <span class=n>uint64</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>uint64</span>          <span class=nf>walkaddr</span><span class=p>(</span><span class=n>pagetable_t</span><span class=p>,</span> <span class=n>uint64</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span>             <span class=nf>copyout</span><span class=p>(</span><span class=n>pagetable_t</span><span class=p>,</span> <span class=n>uint64</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=p>,</span> <span class=n>uint64</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span>             <span class=nf>copyin</span><span class=p>(</span><span class=n>pagetable_t</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=p>,</span> <span class=n>uint64</span><span class=p>,</span> <span class=n>uint64</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span>             <span class=nf>copyinstr</span><span class=p>(</span><span class=n>pagetable_t</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=p>,</span> <span class=n>uint64</span><span class=p>,</span> <span class=n>uint64</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span>            <span class=nf>vmprint</span><span class=p>(</span><span class=n>pagetable_t</span><span class=p>);</span> <span class=c1>// 在问题一被使用
</span></span></span></code></pre></div><p>最后，修改<code>vm.c</code>中的<code>kvmpa</code>，将原先的<code>kernel_pagetable</code>改成<code>myproc()->kernelpt</code>。不要忘记引一下包。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;spinlock.h&#34; </span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;proc.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>uint64</span>
</span></span><span class=line><span class=cl><span class=nf>kvmpa</span><span class=p>(</span><span class=n>uint64</span> <span class=n>va</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>off</span> <span class=o>=</span> <span class=n>va</span> <span class=o>%</span> <span class=n>PGSIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>pte_t</span> <span class=o>*</span><span class=n>pte</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>pa</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=n>pte</span> <span class=o>=</span> <span class=n>walk</span><span class=p>(</span><span class=n>myproc</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>kernelpt</span><span class=p>,</span> <span class=n>va</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>pte</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>panic</span><span class=p>(</span><span class=s>&#34;kvmpa&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>((</span><span class=o>*</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_V</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>panic</span><span class=p>(</span><span class=s>&#34;kvmpa&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>pa</span> <span class=o>=</span> <span class=n>PTE2PA</span><span class=p>(</span><span class=o>*</span><span class=n>pte</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>pa</span><span class=o>+</span><span class=n>off</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><div class=post_footer><div class=meta><div class=info><span class="field tags"><i class=ri-stack-line></i>
<a href=https://yzhe819.github.io/tags/%E4%B8%AD%E6%96%87/>中文</a>
<a href=https://yzhe819.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a>
<a href=https://yzhe819.github.io/tags/6.s081/>6.S081</a></span></div></div></div></div><div class=doc_comments></div></div></div></div><a id=back_to_top href=# class=back_to_top><i class=ri-arrow-up-s-line></i></a><footer class=footer><div class=powered_by><a href=https://varkai.com>Designed by VarKai,</a>
<a href=http://www.gohugo.io/>Proudly published with Hugo</a></div><div class=footer_slogan><span></span></div></footer><script src=https://yzhe819.github.io/js/jquery-3.5.1.min.js></script>
<link href=https://yzhe819.github.io/css/fancybox.min.css rel=stylesheet><script src=https://yzhe819.github.io/js/fancybox.min.js></script>
<script src=https://yzhe819.github.io/js/zozo.js></script>
<script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style></body></html>