<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="yzhe819"><title>MIT 6.S081 Lab 2 系统调用 ｜ yzhe819</title><meta name=description content=" 本篇文章是第二个lab的记录
完成了基础的实验室内容
挑战练习有时间会再看看
官网链接：Lab: system calls
代码仓库：Github
"><meta name=keywords content="yzhe819,zozo"><link rel="shortcut icon" href=https://yzhe819.github.io/images/favicon.ico><link rel=stylesheet type=text/css media=screen href=https://yzhe819.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css><link rel=stylesheet type=text/css media=screen href=https://yzhe819.github.io/css/zozo.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css><link rel=stylesheet type=text/css media=screen href=https://yzhe819.github.io/css/highlight.css></head><body><div class="main animate__animated animate__fadeInDown"><div class="nav_container animated fadeInDown"><div class=site_nav id=site_nav><ul><li><a href=/>Home</a></li><li><a href=/posts/>Archive</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul></div><div class=menu_icon><a id=menu_icon><i class=ri-menu-line></i></a></div></div><div class="header animated fadeInDown"><div class=site_title_container><div class=site_title><h1><a href=https://yzhe819.github.io/><span>yzhe819</span></a></h1></div><div class=description><p class=sub_title>yzhe819's Blog</p><div class=my_socials><a href=https://github.com/yzhe819 title=github target=_blank><i class=ri-github-fill></i></a>
<a href=https://yzhe819.github.io/index.xml type=application/rss+xml title=rss target=_blank><i class=ri-rss-fill></i></a></div></div></div></div><div class=content><div class=post_page><div class="post animate__animated animate__fadeInDown"><div class="post_title post_detail_title"><h2><a href=/posts/mit-6.s081-lab-2/>MIT 6.S081 Lab 2 系统调用</a></h2><span class=date>2022.06.14</span></div><div class="post_content markdown"><blockquote><p>本篇文章是第二个lab的记录</p></blockquote><p>完成了基础的实验室内容</p><p>挑战练习有时间会再看看</p><p>官网链接：<a href=https://pdos.csail.mit.edu/6.828/2020/labs/syscall.html>Lab: system calls</a></p><p>代码仓库：<a href=https://github.com/yzhe819/MIT-6.S081/tree/syscall>Github</a></p><h2 id=系统调用追踪moderate>系统调用追踪（moderate）</h2><p>在本作业中，您将添加一个系统调用跟踪功能，该功能可能会在以后调试实验时对您有所帮助。您将创建一个新的<code>trace</code>系统调用来控制跟踪。它应该有一个参数，这个参数是一个整数“掩码”（mask），它的比特位指定要跟踪的系统调用。例如，要跟踪<code>fork</code>系统调用，程序调用<code>trace(1 &lt;&lt; SYS_fork)</code>，其中<code>SYS_fork</code>是<strong>kernel/syscall.h</strong>中的系统调用编号。如果在掩码中设置了系统调用的编号，则必须修改xv6内核，以便在每个系统调用即将返回时打印出一行。该行应该包含进程id、系统调用的名称和返回值；您不需要打印系统调用参数。<code>trace</code>系统调用应启用对调用它的进程及其随后派生的任何子进程的跟踪，但不应影响其他进程。</p><p>我们提供了一个用户级程序版本的<code>trace</code>，它运行另一个启用了跟踪的程序（参见<strong>user/trace.c</strong>）。完成后，您应该看到如下输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ trace <span class=m>32</span> grep hello README
</span></span><span class=line><span class=cl>3: syscall <span class=nb>read</span> -&gt; <span class=m>1023</span>
</span></span><span class=line><span class=cl>3: syscall <span class=nb>read</span> -&gt; <span class=m>966</span>
</span></span><span class=line><span class=cl>3: syscall <span class=nb>read</span> -&gt; <span class=m>70</span>
</span></span><span class=line><span class=cl>3: syscall <span class=nb>read</span> -&gt; <span class=m>0</span>
</span></span><span class=line><span class=cl>$
</span></span><span class=line><span class=cl>$ trace <span class=m>2147483647</span> grep hello README
</span></span><span class=line><span class=cl>4: syscall trace -&gt; <span class=m>0</span>
</span></span><span class=line><span class=cl>4: syscall <span class=nb>exec</span> -&gt; <span class=m>3</span>
</span></span><span class=line><span class=cl>4: syscall open -&gt; <span class=m>3</span>
</span></span><span class=line><span class=cl>4: syscall <span class=nb>read</span> -&gt; <span class=m>1023</span>
</span></span><span class=line><span class=cl>4: syscall <span class=nb>read</span> -&gt; <span class=m>966</span>
</span></span><span class=line><span class=cl>4: syscall <span class=nb>read</span> -&gt; <span class=m>70</span>
</span></span><span class=line><span class=cl>4: syscall <span class=nb>read</span> -&gt; <span class=m>0</span>
</span></span><span class=line><span class=cl>4: syscall close -&gt; <span class=m>0</span>
</span></span><span class=line><span class=cl>$
</span></span><span class=line><span class=cl>$ grep hello README
</span></span><span class=line><span class=cl>$
</span></span><span class=line><span class=cl>$ trace <span class=m>2</span> usertests forkforkfork
</span></span><span class=line><span class=cl>usertests starting
</span></span><span class=line><span class=cl><span class=nb>test</span> forkforkfork: 407: syscall fork -&gt; <span class=m>408</span>
</span></span><span class=line><span class=cl>408: syscall fork -&gt; <span class=m>409</span>
</span></span><span class=line><span class=cl>409: syscall fork -&gt; <span class=m>410</span>
</span></span><span class=line><span class=cl>410: syscall fork -&gt; <span class=m>411</span>
</span></span><span class=line><span class=cl>409: syscall fork -&gt; <span class=m>412</span>
</span></span><span class=line><span class=cl>410: syscall fork -&gt; <span class=m>413</span>
</span></span><span class=line><span class=cl>409: syscall fork -&gt; <span class=m>414</span>
</span></span><span class=line><span class=cl>411: syscall fork -&gt; <span class=m>415</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>$
</span></span></code></pre></div><p>在上面的第一个例子中，<code>trace</code>调用<code>grep</code>，仅跟踪了<code>read</code>系统调用。<code>32</code>是<code>1&lt;&lt;SYS_read</code>。在第二个示例中，<code>trace</code>在运行<code>grep</code>时跟踪所有系统调用；<code>2147483647</code>将所有31个低位置为1。在第三个示例中，程序没有被跟踪，因此没有打印跟踪输出。在第四个示例中，在<code>usertests</code>中测试的<code>forkforkfork</code>中所有子孙进程的<code>fork</code>系统调用都被追踪。如果程序的行为如上所示，则解决方案是正确的（尽管进程ID可能不同）</p><h3 id=提示>提示：</h3><ul><li>在<strong>Makefile</strong>的<strong>UPROGS</strong>中添加<code>$U/_trace</code></li><li>运行<code>make qemu</code>，您将看到编译器无法编译<strong>user/trace.c</strong>，因为系统调用的用户空间存根还不存在：将系统调用的原型添加到<strong>user/user.h</strong>，存根添加到<strong>user/usys.pl</strong>，以及将系统调用编号添加到<strong>kernel/syscall.h</strong>，<strong>Makefile</strong>调用perl脚本<strong>user/usys.pl</strong>，它生成实际的系统调用存根<strong>user/usys.S</strong>，这个文件中的汇编代码使用RISC-V的<code>ecall</code>指令转换到内核。一旦修复了编译问题（<em>注：如果编译还未通过，尝试先<code>make clean</code>，再执行<code>make qemu</code></em>），就运行<code>trace 32 grep hello README</code>；但由于您还没有在内核中实现系统调用，执行将失败。</li><li>在<strong>kernel/sysproc.c</strong>中添加一个<code>sys_trace()</code>函数，它通过将参数保存到<code>proc</code>结构体（请参见<strong>kernel/proc.h</strong>）里的一个新变量中来实现新的系统调用。从用户空间检索系统调用参数的函数在<strong>kernel/syscall.c</strong>中，您可以在<strong>kernel/sysproc.c</strong>中看到它们的使用示例。</li><li>修改<code>fork()</code>（请参阅<strong>kernel/proc.c</strong>）将跟踪掩码从父进程复制到子进程。</li><li>修改<strong>kernel/syscall.c</strong>中的<code>syscall()</code>函数以打印跟踪输出。您将需要添加一个系统调用名称数组以建立索引。</li></ul><h3 id=实现>实现：</h3><p>首先观察题目中提到的<strong>user/trace.c</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>nargv</span><span class=p>[</span><span class=n>MAXARG</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>argc</span> <span class=o>&lt;</span> <span class=mi>3</span> <span class=o>||</span> <span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>&lt;</span> <span class=sc>&#39;0&#39;</span> <span class=o>||</span> <span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>&gt;</span> <span class=sc>&#39;9&#39;</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;Usage: %s mask command</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>trace</span><span class=p>(</span><span class=n>atoi</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;%s: trace failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>argc</span> <span class=o>&amp;&amp;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>MAXARG</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>nargv</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=n>argv</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>exec</span><span class=p>(</span><span class=n>nargv</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>nargv</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这是使用用例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ trace <span class=m>32</span> grep hello README
</span></span></code></pre></div><p>根据代码可得，第一个判断是检查参数是否足够，以及第一个参数，整数“掩码”（mask），它是否有效。 然后就是将这个命令行参数（存成char array）转为整数。最后的for loop只是普通的将后续参数存一下（相当于去掉例子中开头的trace和32），然后接下来用exec调用。</p><p>了解完这个trace函数后，我们可以根据提示将需要的代码补上，首先在<strong>Makefile</strong>里面的<strong>UPROGS</strong>把**$U/_trace**加上。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_wc</span>\
</span></span><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_zombie</span>\
</span></span><span class=line><span class=cl>	<span class=err>$</span><span class=n>U</span><span class=o>/</span><span class=n>_trace</span>
</span></span></code></pre></div><p>然后去<strong>user.h</strong>里面加调用原型加上，因为题目上了只有一个整数参数，使用直接<code>trace(int)</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sleep</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uptime</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>trace</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span></code></pre></div><p>然后去到<strong>user/usys.pl</strong>把entry加上：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>entry(&#34;sleep&#34;);
</span></span><span class=line><span class=cl>entry(&#34;uptime&#34;);
</span></span><span class=line><span class=cl>entry(&#34;trace&#34;);
</span></span></code></pre></div><p>最后添加system call number到kernel/syscall里面，直接加到最后：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define SYS_mkdir  20
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_close  21
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_trace  22
</span></span></span></code></pre></div><p>到此配置就完成了，可以真正的实现功能了！</p><p>首先要修改kernel/proc.h中的proc结构，这是用来存储进程状态的数据结构，给他加一个mask用于追踪:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Per-process state
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>proc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>spinlock</span> <span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// p-&gt;lock must be held when using these:
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>enum</span> <span class=n>procstate</span> <span class=n>state</span><span class=p>;</span>        <span class=c1>// Process state
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>parent</span><span class=p>;</span>         <span class=c1>// Parent process
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=o>*</span><span class=n>chan</span><span class=p>;</span>                  <span class=c1>// If non-zero, sleeping on chan
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>killed</span><span class=p>;</span>                  <span class=c1>// If non-zero, have been killed
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>xstate</span><span class=p>;</span>                  <span class=c1>// Exit status to be returned to parent&#39;s wait
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>pid</span><span class=p>;</span>                     <span class=c1>// Process ID
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// these are private to the process, so p-&gt;lock need not be held.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint64</span> <span class=n>kstack</span><span class=p>;</span>               <span class=c1>// Virtual address of kernel stack
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint64</span> <span class=n>sz</span><span class=p>;</span>                   <span class=c1>// Size of process memory (bytes)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>pagetable_t</span> <span class=n>pagetable</span><span class=p>;</span>       <span class=c1>// User page table
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>trapframe</span> <span class=o>*</span><span class=n>trapframe</span><span class=p>;</span> <span class=c1>// data page for trampoline.S
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>context</span> <span class=n>context</span><span class=p>;</span>      <span class=c1>// swtch() here to run process
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>ofile</span><span class=p>[</span><span class=n>NOFILE</span><span class=p>];</span>  <span class=c1>// Open files
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>cwd</span><span class=p>;</span>           <span class=c1>// Current directory
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>char</span> <span class=n>name</span><span class=p>[</span><span class=mi>16</span><span class=p>];</span>               <span class=c1>// Process name (debugging)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>mask</span><span class=p>;</span> <span class=c1>// Process mask (for tracing)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>然后转移到kernel/sysproc.c里面添加sys_trace()：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>uint64</span>
</span></span><span class=line><span class=cl><span class=nf>sys_trace</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>argint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>myproc</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>mask</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这里的函数是获取args[1]的值，然后将它存到我们新添加的mask里面。更加完整的版本应该是还需要添加获取判断，看看有没有成功获取参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>uint64</span>
</span></span><span class=line><span class=cl><span class=nf>sys_trace</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>argint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>n</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=c1>// 判断参数是否获取成功
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>myproc</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>mask</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>    <span class=c1>// 将argv[1]保存到当前进程的mask中
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>因为题目提到<code>trace</code>系统调用应启用对调用它的进程及其随后派生的任何子进程的跟踪，所以我们需要在fork的时候将mask值也保存到子进程里面。fork是在kernel/proc.c里面的，这里直接将原函数附上。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>fork</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>np</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Allocate process.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>((</span><span class=n>np</span> <span class=o>=</span> <span class=n>allocproc</span><span class=p>())</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Copy user memory from parent to child.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>uvmcopy</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>np</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>freeproc</span><span class=p>(</span><span class=n>np</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>np</span><span class=o>-&gt;</span><span class=n>sz</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>np</span><span class=o>-&gt;</span><span class=n>parent</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// copy saved user registers.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=o>*</span><span class=p>(</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=p>)</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Cause fork to return 0 in the child.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>np</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>a0</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// increment reference counts on open file descriptors.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>NOFILE</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>ofile</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>      <span class=n>np</span><span class=o>-&gt;</span><span class=n>ofile</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>filedup</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>ofile</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=n>np</span><span class=o>-&gt;</span><span class=n>cwd</span> <span class=o>=</span> <span class=n>idup</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>cwd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>safestrcpy</span><span class=p>(</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>np</span><span class=o>-&gt;</span><span class=n>mask</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>mask</span><span class=p>;</span> <span class=c1>// copy the process&#39;s signal mask
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>pid</span> <span class=o>=</span> <span class=n>np</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>np</span><span class=o>-&gt;</span><span class=n>state</span> <span class=o>=</span> <span class=n>RUNNABLE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>最后修改一下<strong>kernel/syscall.c</strong>中的<code>syscall()</code>函数以打印跟踪输出。这部分需要在(*syscalls[])(void)里面加一下。还有手动给他建个字符串数组给他存一下调用的方法名，方便使用。以及加一下函数声明在顶上：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>extern</span> <span class=n>uint64</span> <span class=nf>sys_write</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=n>uint64</span> <span class=nf>sys_uptime</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=n>uint64</span> <span class=nf>sys_trace</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=nf>uint64</span> <span class=p>(</span><span class=o>*</span><span class=n>syscalls</span><span class=p>[])(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>[</span><span class=n>SYS_trace</span><span class=p>]</span>   <span class=n>sys_trace</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// translate from the above system call function names
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>char</span> <span class=o>*</span><span class=n>syscalls_name</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_fork</span><span class=p>]</span>    <span class=s>&#34;fork&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_exit</span><span class=p>]</span>    <span class=s>&#34;exit&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_wait</span><span class=p>]</span>    <span class=s>&#34;wait&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_pipe</span><span class=p>]</span>    <span class=s>&#34;pipe&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_read</span><span class=p>]</span>    <span class=s>&#34;read&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_kill</span><span class=p>]</span>    <span class=s>&#34;kill&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_exec</span><span class=p>]</span>    <span class=s>&#34;exec&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_fstat</span><span class=p>]</span>   <span class=s>&#34;fstat&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_chdir</span><span class=p>]</span>   <span class=s>&#34;chdir&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_dup</span><span class=p>]</span>     <span class=s>&#34;dup&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_getpid</span><span class=p>]</span>  <span class=s>&#34;getpid&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_sbrk</span><span class=p>]</span>    <span class=s>&#34;sbrk&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_sleep</span><span class=p>]</span>   <span class=s>&#34;sleep&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_uptime</span><span class=p>]</span>  <span class=s>&#34;uptime&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_open</span><span class=p>]</span>    <span class=s>&#34;open&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_write</span><span class=p>]</span>   <span class=s>&#34;write&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_mknod</span><span class=p>]</span>   <span class=s>&#34;mknod&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_unlink</span><span class=p>]</span>  <span class=s>&#34;unlink&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_link</span><span class=p>]</span>    <span class=s>&#34;link&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_mkdir</span><span class=p>]</span>   <span class=s>&#34;mkdir&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_close</span><span class=p>]</span>   <span class=s>&#34;close&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>SYS_trace</span><span class=p>]</span>   <span class=s>&#34;trace&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>syscall</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>num</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>a7</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>num</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>num</span> <span class=o>&lt;</span> <span class=n>NELEM</span><span class=p>(</span><span class=n>syscalls</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>syscalls</span><span class=p>[</span><span class=n>num</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>a0</span> <span class=o>=</span> <span class=n>syscalls</span><span class=p>[</span><span class=n>num</span><span class=p>]();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// check whether the system call match the tracing mask
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>((</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>num</span><span class=p>)</span> <span class=o>&amp;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>mask</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%d: syscall %s -&gt; %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>syscalls_name</span><span class=p>[</span><span class=n>num</span><span class=p>],</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>a0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%d %s: unknown sys call %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>p</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=n>num</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>a0</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=系统信息moderate>系统信息（moderate）</h1><p>在这个作业中，您将添加一个系统调用<code>sysinfo</code>，它收集有关正在运行的系统的信息。系统调用采用一个参数：一个指向<code>struct sysinfo</code>的指针（参见<strong>kernel/sysinfo.h</strong>）。内核应该填写这个结构的字段：<code>freemem</code>字段应该设置为空闲内存的字节数，<code>nproc</code>字段应该设置为<code>state</code>字段不为<code>UNUSED</code>的进程数。我们提供了一个测试程序<code>sysinfotest</code>；如果输出“<strong>sysinfotest: OK</strong>”则通过。</p><h3 id=提示-1>提示：</h3><ul><li>在<strong>Makefile</strong>的<strong>UPROGS</strong>中添加<code>$U/_sysinfotest</code></li><li>当运行<code>make qemu</code>时，<strong>user/sysinfotest.c</strong>将会编译失败，遵循和上一个作业一样的步骤添加<code>sysinfo</code>系统调用。要在<strong>user/user.h</strong>中声明<code>sysinfo()</code>的原型，需要预先声明<code>struct sysinfo</code>的存在：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>sysinfo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sysinfo</span><span class=p>(</span><span class=k>struct</span> <span class=n>sysinfo</span> <span class=o>*</span><span class=p>);</span>
</span></span></code></pre></div><p>一旦修复了编译问题，就运行<code>sysinfotest</code>；但由于您还没有在内核中实现系统调用，执行将失败。</p><ul><li><code>sysinfo</code>需要将一个<code>struct sysinfo</code>复制回用户空间；请参阅<code>sys_fstat()</code>(<strong>kernel/sysfile.c</strong>)和<code>filestat()</code>(<strong>kernel/file.c</strong>)以获取如何使用<code>copyout()</code>执行此操作的示例。</li><li>要获取空闲内存量，请在<strong>kernel/kalloc.c</strong>中添加一个函数</li><li>要获取可用进程数，请在<strong>kernel/proc.c</strong>中添加一个函数</li></ul><h3 id=实现-1>实现：</h3><p>重复一下之前trace里面的配置：</p><p>添加$U/_sysinfotest，添加函数声明到user.h （记得根据提示声明struct sysinfo），添加entry到usys.pl，添加syscall number到syscall.h，然后加入到syscall函数数组中。这是我的提交：<a href=https://github.com/yzhe819/MIT-6.S081/commit/33d3d512d66a9292b9566fe024bdb6df72f1dbc2>sysinfo config</a></p><p>然后根据提示在<strong>kernel/kalloc.c</strong>中添加一个函数，用于获取空闲内存量。</p><p>直接历遍链表计数，最后乘一下内存页的大小就好，可以加个锁避免冲突。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>uint64</span>
</span></span><span class=line><span class=cl><span class=nf>freemem</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>run</span> <span class=o>*</span><span class=n>r</span> <span class=o>=</span> <span class=n>kmem</span><span class=p>.</span><span class=n>freelist</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>num</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kmem</span><span class=p>.</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>(</span><span class=n>r</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>num</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kmem</span><span class=p>.</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>num</span> <span class=o>*</span> <span class=n>PGSIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>然后在<strong>kernel/proc.c</strong>中添加一个函数，用于获取可用进程数。把所有状态是UNUSED的记一下就可以。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>uint64</span>
</span></span><span class=line><span class=cl><span class=nf>nproc</span><span class=p>(</span><span class=kt>void</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>NPROC</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>proc</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>state</span> <span class=o>!=</span> <span class=n>UNUSED</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=n>n</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>最后在<strong>kernel/sysproc.c</strong>里面调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>uint64</span>
</span></span><span class=line><span class=cl><span class=nf>sys_sysinfo</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>sysinfo</span> <span class=n>info</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>info</span><span class=p>.</span><span class=n>freemem</span> <span class=o>=</span> <span class=n>freemem</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>info</span><span class=p>.</span><span class=n>nproc</span> <span class=o>=</span> <span class=n>nproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// get the virtual address
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint64</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>argaddr</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>addr</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>copyout</span><span class=p>(</span><span class=n>myproc</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>addr</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>info</span><span class=p>,</span> <span class=k>sizeof</span> <span class=n>info</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>重点是前三行代码，直接调用我们的代码就好。后面的那部分是用于将一个<code>struct sysinfo</code>复制回用户空间，就是提示里面说到的copyout用法。</p><p>到此我们的lab 2已经结束了。</p><h2 id=测试与修复>测试与修复：</h2><p>在提交前我们跑一下测试吧，推迟qemu，然后运行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ./grade-lab-syscall
</span></span><span class=line><span class=cl>/usr/bin/env: ‘python<span class=se>\r</span>’: No such file or directory
</span></span></code></pre></div><p>好吧，我再修复一下，然后再次运行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ dos2unix ./grade-lab-syscall
</span></span><span class=line><span class=cl>$ ./grade-lab-syscall
</span></span></code></pre></div><p>结果依然报错：
<img src=/lab2_fail.png alt=报错提示></p><p>报错提示程序没有打印<code>3: syscall read -> 966</code>而是打印了<code>3: syscall read -> 986</code></p><p>想了想后，恍然大悟，需要给readme也调整一下格式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ dos2unix ./readme
</span></span></code></pre></div><p>再次运行，终于全部通过了：
<img src=/lab2_pass.png alt=通过></p></div><div class=post_footer><div class=meta><div class=info><span class="field tags"><i class=ri-stack-line></i>
<a href=https://yzhe819.github.io/tags/%E4%B8%AD%E6%96%87/>中文</a>
<a href=https://yzhe819.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a>
<a href=https://yzhe819.github.io/tags/6.s081/>6.S081</a></span></div></div></div></div><div class=doc_comments></div></div></div></div><a id=back_to_top href=# class=back_to_top><i class=ri-arrow-up-s-line></i></a><footer class=footer><div class=powered_by><a href=https://varkai.com>Designed by VarKai,</a>
<a href=http://www.gohugo.io/>Proudly published with Hugo</a></div><div class=footer_slogan><span></span></div></footer><script src=https://yzhe819.github.io/js/jquery-3.5.1.min.js></script>
<link href=https://yzhe819.github.io/css/fancybox.min.css rel=stylesheet><script src=https://yzhe819.github.io/js/fancybox.min.js></script>
<script src=https://yzhe819.github.io/js/zozo.js></script>
<script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style></body></html>